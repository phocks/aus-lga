<!DOCTYPE html>
<html>
<head>
    <title>Australian LGA</title>
    <meta charset='utf-8' />
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>

    <link rel='stylesheet' href='http://cdn.leafletjs.com/leaflet-0.6.4/leaflet.css' />
    <link rel='stylesheet' href='style.css' />

    <script src='//cdn.leafletjs.com/leaflet-0.6.4/leaflet.js'></script>
    <script src='//code.jquery.com/jquery-2.0.3.min.js'></script>
    <script src='bower_components/d3/d3.js'></script>
</head>
<body>
    <div id='map'></div>

    <script>
      var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/22677/256/{z}/{x}/{y}.png'
          cloudmadeAttribution = 'Map data &copy; 2013 OpenStreetMap contributors, Imagery &copy; 2013 CloudMade',
          cloudmade = L.tileLayer(cloudmadeUrl, { 
            maxZoom: 18,
            attribution: cloudmadeAttribution, 
            styleId: 22677
            }),
          map = L.map('map', {zoom: 6, layers: [cloudmade]}),
          geoData = $.getJSON('AUS_LGA.json'),
          nswData = $.getJSON('nsw.json'),
          vicData = $.getJSON('vic.json'),
          qldData = $.getJSON('qld.json'),
          saData = $.getJSON('sa.json'),
          waData = $.getJSON('wa.json'),
          tasData = $.getJSON('tas.json'),
          ntData = $.getJSON('nt.json'),
          stateData = $.getJSON('states.json'),
          seifaData = $.getJSON('lga_seifa.json');

      $.when( geoData, nswData, vicData, qldData, saData, waData, tasData, ntData, stateData, seifaData )
      .done( function( geoJSON, nswJSON, vicJSON, qldJSON, saJSON, waJSON, tasJSON, ntJSON, stateJSON, seifaJSON ) {
        
        // horrible
        nswJSON[0].forEach(function(l) { 
          geoJSON[0].features.forEach(function(g) {
            if( g.properties.LGA_CODE11 == l.id ) {
              g.properties.data = l;
            }
          });
        });

        vicJSON[0].forEach(function(l) {
          geoJSON[0].features.forEach(function(g) {
            if( g.properties.LGA_CODE11 == l.id ) {
              g.properties.data = l;
            }
          });
        });

        qldJSON[0].forEach(function(l) {
          geoJSON[0].features.forEach(function(g) {
            if( g.properties.LGA_CODE11 == l.id ) {
              g.properties.data = l;
            }
          });
        });

        saJSON[0].forEach(function(l) {
          geoJSON[0].features.forEach(function(g) {
            if( g.properties.LGA_CODE11 == l.id ) {
              g.properties.data = l;
            }
          });
        });

        waJSON[0].forEach(function(l) {
          geoJSON[0].features.forEach(function(g) {
            if( g.properties.LGA_CODE11 == l.id ) {
              g.properties.data = l;
            }
          });
        });

        tasJSON[0].forEach(function(l) {
          geoJSON[0].features.forEach(function(g) {
            if( g.properties.LGA_CODE11 == l.id ) {
              g.properties.data = l;
            }
          });
        });

        ntJSON[0].forEach(function(l) {
          geoJSON[0].features.forEach(function(g) {
            if( g.properties.LGA_CODE11 == l.id ) {
              g.properties.data = l;
            }
          });
        });

        seifaJSON[0].forEach(function(s) {
          geoJSON[0].features.forEach(function(g) {
            if( g.properties.LGA_CODE11 == s.lga_id ) {
              g.properties.seifa = s;
            }
          });
        });

        function getColor(d) {
          return d > 1000 ? '#800026' :
                 d > 500  ? '#BD0026' :
                 d > 200  ? '#E31A1C' :
                 d > 100  ? '#FC4E2A' :
                 d > 50   ? '#FD8D3C' :
                 d > 20   ? '#FEB24C' :
                 d > 10   ? '#FED976' :
                            '#FFEDA0';
        }

        function styleFeature(feature) {
          var density = feature.properties.data && feature.properties.data.density ? 
                feature.properties.data.density : 0;

          return {
              fillColor: getColor(density),
              weight: 1,
              opacity: 0.7,
              color: '#888',
              dashArray: '3',
              fillOpacity: 0.7
          };
        }

        L.geoJson(stateJSON[0], {
          style: {
            fillColor: 'transparent',
            fillOpacity: 0,
            color: '#999',
            opacity: 1,
            width: 0.5,
            weight: 0.5
          }
        }).addTo(map);

        L.geoJson(geoJSON[0], {
          style: styleFeature,
          onEachFeature: function(feature, layer) {

            layer.on({
              click: function() {
                layer.setStyle({
                  color: '#fff',
                  opacity: 1,
                  dashArray: '3',
                  fillOpacity: 1
                });
              },
              mouseover: function(evt) {
                var feature = evt.layer && evt.layer.feature;
                info.update(layer.feature.properties);
              },
            });
          }
        }).addTo(map);

        var info = L.control();
        info.onAdd = function (map) {
          this._div = L.DomUtil.create('div', 'info');
          this.update();
          return this._div;
        };

        function buildGraph(opts) {
          var data = opts.data;
          var el = opts.el;

          var margin = {top: 30, right: 45, bottom: 30, left: 45}, 
              width = 280 - margin.left - margin.right,
              height = 180 - margin.top - margin.bottom;

          // convert to a timestamp so we can use a time scale
          data.forEach(function(d) {
            d.year = (new Date(d.year)).getTime();
          });

          var x = d3.time.scale()
                    .domain([data[0].year, data[data.length-1].year])
                    .range([0, width]);
              y = d3.scale.linear()
                    .domain([d3.min(data, function(d) { return +d.pop }), d3.max(data, function(d) { return +d.pop; })])
                    .range([height, 0]);

          var xAxis = d3.svg.axis().scale(x)
              .orient("bottom")
              .tickFormat(d3.time.format('%y'))
              .tickSize(3)
              .ticks(data.length);

          var yAxis = d3.svg.axis().scale(y)
              .orient("left")
              .tickSize(3)
              .tickValues(y.domain());

          var area = d3.svg.area()
              .interpolate("monotone")
              .x(function(d) { return x(d.year); })
              .y0(height)
              .y1(function(d) { return y(d.pop); });

          var valueline = d3.svg.line()
              .x(function(d) { return x(d.year); }) 
              .y(function(d) { return y(d.pop); });

          var svg = d3.select('.graph')
              .append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
              .append("g")
                  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

          // Add the clip path.
          svg.append("clipPath")
              .attr("id", "clip")
            .append("rect")
              .attr("width", width)
              .attr("height", height);

          // Add the area path.
          // http://bl.ocks.org/mbostock/1166403
          /*svg.append("path")
              .attr("class", "area")
              .attr("clip-path", "url(#clip)")
              .attr("d", area(data));
          */

          svg.append("path") // Add the valueline path.
              .attr("d", valueline(data));

          svg.append("g") // Add the X Axis
              .attr("class", "x axis")
              .attr("transform", "translate(0," + height + ")")
              .call(xAxis);

          svg.append("g")
              .attr("class", "y axis")
              .call(yAxis);

          return svg;
        };

        var formatter = d3.format("0,000");

        // method that we will use to update the control based on feature properties passed
        info.update = function(props) {

          this._div.innerHTML = '<h4>Australian LGA Population Density</h4>' + 
              (props ? 
                '<p>Name: <strong>' + props.data.name + '</strong></p>' + 
                '<p>Area: <strong>' + formatter(props.data.area) + 'km<sup>2</sup></strong></p>' +
                '<p>Population (2012): <strong>' + formatter(props.data['2012']) + '</strong></p>' +
                '<p>Population density: <strong>' + props.data.density + ' people per km<sup>2</sup></strong></p>' +
                '<div class="graph"></div>'
              : '<p>Hover over an LGA</p>');

          if( props ) {
            var graphData = (function(obj) {
                var d = [];
                // get Years
                for( p in obj ) {
                  if( /^\d{4}$/.test(p) ) {
                    d.push({year: p, pop: obj[p] });
                  }
                }
                return d;
              })(props.data);
            
            buildGraph({data: graphData, el: 'graph'});
            console.log(props.seifa);
          }
        };

        info.addTo(map);

        var search = L.control();
        search.onAdd = function(map) {
          this._div = L.DomUtil.create('div', 'search');
          this.update();
          return this._div;
        };

        search.update = function(props) {
          this._div.innerHTML = '<h4>Search</h4>' + 
            '<input id="search" type="search" value="" placeholder="search" class="topcoat-search-input--large">';
        };

        search.addTo(map);

        var legend = L.control();
        legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend'),
                grades = [0, 10, 20, 50, 100, 200, 500, 1000],
                labels = [];

            // loop through our density intervals and generate a label with a colored square for each interval
            for (var i = 0; i < grades.length; i++) {
                div.innerHTML +=
                    '<i style="background:' + getColor(grades[i] + 1) + '"></i> ' +
                    grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] + '<br>' : '+');
            }
            return div;
        };
        legend.addTo(map);

        $('#search').on('click', function(e) {
          console.log(e);
        });

        $('#map').css('height', function() { return document.body.clientHeight || '800px'; });
        map.setView([-33.8600, 151.2111], 6);
      });
    </script>
</body>
</html>
